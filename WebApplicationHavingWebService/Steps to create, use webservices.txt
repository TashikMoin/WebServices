Why RESTAPI is called REST?
It is called REST, because the client initiates transfer of representations of client state.


A REST request from client to server usually contains the following:
- URL Path (e.g. https://api.myapp.com/user)
- HTTP method (GET, PUT, POST, PATCH, DELETE)
- Header (optional) (e.g. authorization credentials)
- Parameters (optional) – values that alter how resources will be returned
- Body (optional) – contains data that needs to be sent to the server




In order for a Web API to be a RESTful API, it must conform to some rules:

- Client-Server model.

- HTTP as common protocol for sending/receiving requests.

- All calls with REST API must be stateless (every request is independent of one another).

- Layered systems (In general, a layered system consists of layers with different units of functionality. The essential characteristics of layered systems are that a Layer communicates by means of pre-defined interfaces and communicate only with the layer above or layer below, and the layers above rely on the layers below to it to perform its functions. Layers can be added, removed, modified, or reordered as the architecture evolves. Example of layered architecture in RESTAPI, webserver receiving request and then calling database server sometimes depending on the nature of request. The webserver and the database server are present at two different layers)

- Caching of resources (storing responses in client machine).






Why RESTAPI is stateless?
Statelessness helps in scaling the APIs to millions of concurrent users by deploying it to multiple servers. Any server can handle any request because there is no session related dependency. Being stateless makes REST APIs less complex – by removing all server-side state synchronization logic.






Why is HTTP stateless?
HTTP is called as a stateless protocol because each request is executed independently, without any knowledge of the requests that were executed before it, which means once the transaction ends the connection between the browser and the server is also lost.





Webservice

Web services are a standardized way for developing interoperable applications i.e enabling an application to invoke a method of another application. These applications can be on the same computer or different computers. 

Web services use open standards and protocols like HTTP, XML and SOAP. Since these are open and well known protocols, applications built on any platform can interoperate with web services. 
For example, a JAVA application can interoperate with a web service built using .NET. Similarly a web service built using JAVA can be consumed by a .NET application.


Steps To Create A WebService

- Create a web application (.net framework, or .net core)

- Go > new item to project > add web service(ASMX) to the project.

- (Read all the comments of TestWebService.asmx file inside WebApplicationHavingWebService project).

- To run a webservices, build the project, right click on webservice file and open with browser.

- By default, .net shows SOAP+XML request and response message syntax of all the functions present in a webservice, through this xml+soap format of message, the webservice do communication with other applications present either on same machine or on other machines. We can see these request and response messages text by clicking the publicly/exposed methods of a webservice from the homepage of webservice when opened in browser. By default, It also provides a interface to pass arguments to the functions of a webservice to test the functions. We can invoke these functions from other application, running in different systems, machines, built on different languages.

- So far, we are using the browser as an application to access/consume the functions of the web service using the default pages of the webservice generated by .net to consume the webservice functions.

- At homepage of a webservice, there is a link, "service description", by clicking this link we are redirected to a WSDL (Web Service Description Language) page. This description language contains request and response XML/SOAP messages generated for communication, the request message contains the parameters and the response messages contains the return type of the functions, each function has its own request and response XML+SOAP message. When consumer applications are other applications and not the .net default page of the webservice, this WSDL (Web Service Description Language)'s description is used by the consumer applications to access/consume the webservice functions. The other applications use these description language, and they generate a proxy class to access the functions of a webservice. These webservices can be consumed by console applications, desktop applications and other web applications created in .net or in other languages.



Access/Consume a Web Service from another application (it can be java, .net or any language application)

- To access/consume a .net webservice from another .net application, lets create a console application to test a .net webservice. 

- Create a console/web/etc application independently (do not create under same solution to avoid errors).

- We will create console application.

- Go to references of the console application > right click, click add a service reference,
	under service reference, inside address, add path/url of the WSDL description of the webservice and click Go, give a namespace name and then Ok.

- Now, the other application will use this web service description language (WSDL) and it will automatically generate a proxy class that will be calling base class methods (webservice class methods). The base class is present in the webservice and the proxy class helps in accessing/consuming these methods of the webservice base class by calling the methods of the base class inside the methods of the proxy class.

- To access/consume the webservice, create instance of the generated proxy class after adding the reference of the webservice.

- To see the proxy class, under "connected services" in solution explorer of the console application, there will be a folder with the same namespace name that was provided while creating the reference of the webservice. click it and then click "show all files button" that is located at the top of the solution explorer it will then expand and will show all the files under that namespace. There will be a "Reference.cs" file under "Reference.svcmap". This Reference.cs class contains the proxy class having access of all the base class methods.

- Import the namespace in the files of the console application where you want to access/consume the functions of the webservice, create object of the proxy class and call the methods of the webservice using the instances of the proxy classes. For now, we are doing this inside program.cs file.

- When we call a webservice method using a proxy class object, at backend, the proxy class will generate a request XML+SOAP message by itself and send that XML+SOAP format message request to the webservice and when the webservice gives it a XML+SOAP message format response in return, it converts that XML+SOAP message response into C# objects back. This is called serialization and deserialization which is done by the proxy class. The developer does not have to write code to generate XML+SOAP message format message to send requests to the web services.





SOAP (Message protocol used by web services)

SOAP is a messaging protocol for exchanging information between two computers based on XML over the internet. SOAP messages are purely written in XML which is why they are platform and language independent.

The SOAP <Envelope> is the root element in every SOAP message. It contains two child elements, an optional <Header>, and a mandatory <Body>. The SOAP <Header> is an optional subelement of the SOAP envelope. It is used to pass application-related information that is to be processed by SOAP nodes along the message path.


